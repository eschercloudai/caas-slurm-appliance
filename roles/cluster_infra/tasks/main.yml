- debug:
    msg: |
      terraform_backend_type: {{ terraform_backend_type }}
      terraform_state: {{ terraform_state }}
      cluster_upgrade_system_packages: {{ cluster_upgrade_system_packages | default('undefined') }}

# We need to convert the floating IP id to an address for Terraform
# if we we have cluster_floating_ip, otherwise assume that we're
# assigning the FIP in Terraform and that it will be available in
# outputs.cluster_gateway_ip.

- block:
    - name: Look up floating IP
      include_role:
        name: stackhpc.terraform.infra
        tasks_from: lookup_floating_ip
      vars:
        os_floating_ip_id: "{{ cluster_floating_ip }}"

    - name: Set floating IP address fact
      set_fact:
        cluster_floating_ip_address: "{{ os_floating_ip_info.floating_ip_address }}"

  when: cluster_floating_ip is defined

- name: Install Terraform binary
  include_role:
    name: stackhpc.terraform.install

- name: Make Terraform project directory
  file:
    path: "{{ terraform_project_path }}"
    state: directory

- name: Write backend configuration
  copy:
    content: |
      terraform {
        backend "{{ terraform_backend_type }}" { }
      }
    dest: "{{ terraform_project_path }}/backend.tf"

# Patching in this appliance is implemented as a switch to a new base image
# So unless explicitly patching, we want to use the same image as last time
# To do this, we query the previous Terraform state before updating
- block:
    - name: Get previous Terraform state
      stackhpc.terraform.terraform_output:
        binary_path: "{{ terraform_binary_path }}"
        project_path: "{{ terraform_project_path }}"
        backend_config: "{{ terraform_backend_config }}"
      register: cluster_infra_terraform_output

    - name: Extract image from Terraform state
      set_fact:
        cluster_previous_image: "{{ cluster_infra_terraform_output.outputs.cluster_image.value }}"
      when: '"cluster_image" in cluster_infra_terraform_output.outputs'
  when:
    - terraform_state == "present"
    - cluster_upgrade_system_packages is not defined or not cluster_upgrade_system_packages

- name: Detect volume device prefix from image metadata
  block:
    - name: Get image metadata from OpenStack API
      openstack.cloud.image_info:
        image: "{{ cluster_previous_image | default(cluster_image) }}"
      register: cluster_image_info

    - name: Set volume_device_prefix fact
      set_fact:
        block_device_prefix: >-
           {{
              'sd' if cluster_image_info.image.metadata.hw_scsi_model is defined and
              cluster_image_info.image.metadata.hw_scsi_model in scsi_models
              else 'vd'
           }}
  # Only run when block_device_prefix isn't set as an extravar
  when: block_device_prefix is not defined


- name: Template Terraform files into project directory
  template:
    src: >-
      {{
        "{}{}.j2".format(
          (
             cluster_terraform_template_dir ~ "/"
             if cluster_terraform_template_dir is defined
             else ""
          ),
          item
        )
      }}
    dest: "{{ terraform_project_path }}/{{ item }}"
  loop:
    - outputs.tf
    - providers.tf
    - resources.tf
  when: not do_not_change_terraform | default(False)

- name: Provision infrastructure
  include_role:
    name: stackhpc.terraform.infra

# for nodes with cx5 cards we need to define default firewalld rules as per what secgroups SHOULD be there bus aren't.
# for that we need to get all the securtity group data
- openstack.cloud.security_group_info:
    name: "{{ item }}"
  register: secgroup_lookup
  loop: "{{ hostvars[groups['openstack'][0]].terraform_provision.outputs.required_secgroups.value }}"
  when:
    - hostvars[groups['openstack'][0]].terraform_provision.outputs.required_secgroups is defined
    - hostvars[groups['openstack'][0]].terraform_provision.outputs.required_secgroups.value is defined
    - hostvars[groups['openstack'][0]].terraform_provision.outputs.required_secgroups.value is iterable

- name: convert cluster node list fact to dictionary
  set_fact:
    cluster_nodes_dict: "{{ hostvars[groups['openstack'][0]].terraform_provision.outputs.cluster_nodes.value | key_generic_list_of_dicts('name') }}"
  when:
    - hostvars[groups['openstack'][0]].terraform_provision.outputs.cluster_nodes.value is defined

- name: Set cluster_floating_ip_address fact
  set_fact:
    cluster_floating_ip_address: "{{ hostvars[groups['openstack'][0]].terraform_provision.outputs.cluster_gateway_ip.value }}"
  when:
    - terraform_state == "present"

# The hosts provisioned by Terraform are put into a primary group by the role
# These tasks then add those hosts to additional groups depending on the selected options
- name: Add cluster hosts to required groups
  add_host:
    name: "{{ item }}"
    groups: "{{ hostvars[item].group_names | stackhpc.terraform.terraform_infra_expand_groups(cluster_groups_required) }}"
  loop: "{{ groups.get('cluster', []) }}"

- name: Add cluster hosts to OOD groups
  add_host:
    name: "{{ item }}"
    groups: "{{ hostvars[item].group_names | stackhpc.terraform.terraform_infra_expand_groups(cluster_groups_ood) }}"
  loop: "{{ groups.get('cluster', []) }}"

- name: Add cluster hosts to monitoring groups
  add_host:
    name: "{{ item }}"
    groups: "{{ hostvars[item].group_names | stackhpc.terraform.terraform_infra_expand_groups(cluster_groups_monitoring) }}"
  loop: "{{ groups.get('cluster', []) }}"

- name: Add cluster hosts to validation groups
  add_host:
    name: "{{ item }}"
    groups: "{{ hostvars[item].group_names | stackhpc.terraform.terraform_infra_expand_groups(cluster_groups_validation) }}"
  loop: "{{ groups.get('cluster', []) }}"
  when: cluster_run_validation | default(false) | bool

- name: Add cluster hosts to Zenith groups
  add_host:
    name: "{{ item }}"
    groups: "{{ hostvars[item].group_names | stackhpc.terraform.terraform_infra_expand_groups(cluster_groups_zenith) }}"
  loop: "{{ groups.get('cluster', []) }}"
  when: zenith_subdomain_monitoring is defined

- name: on nodes with port security off update the firewalld_configs_default var using the secgroups that would have been appplied in TF if port security was on
  set_fact:
    firewalld_configs: "{{ secgroup_lookup.results | items_to_sgdict | sgdicts_to_fwd(hostvars[groups['openstack'][0]].cluster_nodes_dict[item].secgroup_list) + firewalld_configs_extra | selectattr('group', 'in',  group_names) | map(attribute='rule') }}"
  delegate_to: "{{ item }}"
  delegate_facts: true
  loop: "{{ groups.get('firewalld', []) }}"
  when:
    - hostvars[groups['openstack'][0]].cluster_nodes_dict[item].secgroup_list is defined

- name: Dump firewalld_configs_default when overriding due to port security being unavailiable
  debug:
    var: hostvars[item].firewalld_configs_default
  when:
    - hostvars[groups['openstack'][0]].cluster_nodes_dict[item].secgroup_list is defined
  loop: "{{ groups.get('cluster', []) }}"


